use crate::db::DbPool;
use crate::models::Scrobble;
use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NoveltyReport {
    pub timeline: Vec<NoveltyPoint>,
    pub summary: NoveltySummary,
    pub new_artists_discovered: Vec<ArtistDiscovery>,
    pub top_comfort_tracks: Vec<ComfortTrack>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NoveltyPoint {
    pub period: String,
    pub total_scrobbles: i64,
    pub new_tracks: i64,
    pub repeat_tracks: i64,
    pub new_artists: i64,
    pub repeat_artists: i64,
    pub novelty_ratio: f64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NoveltySummary {
    pub total_scrobbles: i64,
    pub total_unique_tracks: i64,
    pub total_unique_artists: i64,
    pub avg_novelty_ratio: f64,
    pub most_exploratory_period: String,
    pub least_exploratory_period: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ArtistDiscovery {
    pub artist: String,
    pub first_heard: DateTime<Utc>,
    pub period: String,
    pub total_plays: i64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ComfortTrack {
    pub artist: String,
    pub track: String,
    pub play_count: i64,
    pub first_heard: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy)]
pub enum Granularity {
    Day,
    Week,
    Month,
}

impl Granularity {
    pub fn format_period(&self, dt: &DateTime<Utc>) -> String {
        match self {
            Granularity::Day => dt.format("%Y-%m-%d").to_string(),
            Granularity::Week => dt.format("%Y-W%V").to_string(),
            Granularity::Month => dt.format("%Y-%m").to_string(),
        }
    }
}

pub fn generate_novelty_report(
    pool: &DbPool,
    start: Option<DateTime<Utc>>,
    end: Option<DateTime<Utc>>,
    granularity: Granularity,
) -> Result<NoveltyReport> {
    // Fetch all scrobbles in range
    let scrobbles = if let (Some(s), Some(e)) = (start, end) {
        crate::db::get_scrobbles_in_range(pool, s, e)?
    } else {
        crate::db::get_scrobbles(pool, Some(1_000_000), Some(0))?
    };
    
    if scrobbles.is_empty() {
        return Ok(NoveltyReport {
            timeline: Vec::new(),
            summary: NoveltySummary {
                total_scrobbles: 0,
                total_unique_tracks: 0,
                total_unique_artists: 0,
                avg_novelty_ratio: 0.0,
                most_exploratory_period: String::new(),
                least_exploratory_period: String::new(),
            },
            new_artists_discovered: Vec::new(),
            top_comfort_tracks: Vec::new(),
        });
    }
    
    // Build first occurrence maps
    let (first_track_occurrence, first_artist_occurrence) = build_first_occurrence_maps(&scrobbles);
    
    // Group scrobbles by period
    let mut period_scrobbles: HashMap<String, Vec<&Scrobble>> = HashMap::new();
    for scrobble in &scrobbles {
        let period = granularity.format_period(&scrobble.timestamp);
        period_scrobbles.entry(period).or_default().push(scrobble);
    }
    
    // Build timeline
    let mut timeline = Vec::new();
    for (period, period_scrobbles_list) in &period_scrobbles {
        let point = compute_novelty_point(
            period.clone(),
            period_scrobbles_list,
            &first_track_occurrence,
            &first_artist_occurrence,
        );
        timeline.push(point);
    }
    
    // Sort timeline by period
    timeline.sort_by(|a, b| a.period.cmp(&b.period));
    
    // Compute summary
    let summary = compute_novelty_summary(&timeline, &scrobbles);
    
    // Find new artists discovered
    let new_artists_discovered = find_new_artists_discovered(
        &scrobbles,
        &first_artist_occurrence,
        granularity,
    );
    
    // Find top comfort tracks
    let top_comfort_tracks = find_top_comfort_tracks(&scrobbles, 10);
    
    Ok(NoveltyReport {
        timeline,
        summary,
        new_artists_discovered,
        top_comfort_tracks,
    })
}

fn build_first_occurrence_maps(
    scrobbles: &[Scrobble],
) -> (HashMap<(String, String), DateTime<Utc>>, HashMap<String, DateTime<Utc>>) {
    let mut first_track_occurrence: HashMap<(String, String), DateTime<Utc>> = HashMap::new();
    let mut first_artist_occurrence: HashMap<String, DateTime<Utc>> = HashMap::new();
    
    for scrobble in scrobbles {
        let track_key = (scrobble.artist.clone(), scrobble.track.clone());
        
        // Track first occurrence
        first_track_occurrence
            .entry(track_key)
            .or_insert(scrobble.timestamp);
        
        // Artist first occurrence
        first_artist_occurrence
            .entry(scrobble.artist.clone())
            .or_insert(scrobble.timestamp);
    }
    
    (first_track_occurrence, first_artist_occurrence)
}

fn compute_novelty_point(
    period: String,
    scrobbles: &[&Scrobble],
    first_track_occurrence: &HashMap<(String, String), DateTime<Utc>>,
    first_artist_occurrence: &HashMap<String, DateTime<Utc>>,
) -> NoveltyPoint {
    let total_scrobbles = scrobbles.len() as i64;
    
    let mut new_tracks = 0;
    let mut new_artists_in_period = HashSet::new();
    let mut seen_tracks = HashSet::new();
    let mut seen_artists = HashSet::new();
    
    for scrobble in scrobbles {
        let track_key = (scrobble.artist.clone(), scrobble.track.clone());
        
        // Check if this is the first time hearing this track (globally)
        if let Some(&first_heard) = first_track_occurrence.get(&track_key) {
            if first_heard == scrobble.timestamp && !seen_tracks.contains(&track_key) {
                new_tracks += 1;
            }
        }
        seen_tracks.insert(track_key);
        
        // Check if this is the first time hearing this artist (globally)
        if let Some(&first_heard) = first_artist_occurrence.get(&scrobble.artist) {
            if first_heard == scrobble.timestamp && !seen_artists.contains(&scrobble.artist) {
                new_artists_in_period.insert(scrobble.artist.clone());
            }
        }
        seen_artists.insert(scrobble.artist.clone());
    }
    
    let new_artists = new_artists_in_period.len() as i64;
    let repeat_tracks = total_scrobbles - new_tracks;
    let repeat_artists = seen_artists.len() as i64 - new_artists;
    
    let novelty_ratio = if total_scrobbles > 0 {
        new_tracks as f64 / total_scrobbles as f64
    } else {
        0.0
    };
    
    NoveltyPoint {
        period,
        total_scrobbles,
        new_tracks,
        repeat_tracks,
        new_artists,
        repeat_artists,
        novelty_ratio,
    }
}

fn compute_novelty_summary(timeline: &[NoveltyPoint], scrobbles: &[Scrobble]) -> NoveltySummary {
    let total_scrobbles = scrobbles.len() as i64;
    
    let unique_tracks: HashSet<_> = scrobbles
        .iter()
        .map(|s| (s.artist.clone(), s.track.clone()))
        .collect();
    
    let unique_artists: HashSet<_> = scrobbles
        .iter()
        .map(|s| s.artist.clone())
        .collect();
    
    let avg_novelty_ratio = if !timeline.is_empty() {
        timeline.iter().map(|p| p.novelty_ratio).sum::<f64>() / timeline.len() as f64
    } else {
        0.0
    };
    
    let most_exploratory = timeline
        .iter()
        .max_by(|a, b| a.novelty_ratio.partial_cmp(&b.novelty_ratio).unwrap())
        .map(|p| p.period.clone())
        .unwrap_or_default();
    
    let least_exploratory = timeline
        .iter()
        .min_by(|a, b| a.novelty_ratio.partial_cmp(&b.novelty_ratio).unwrap())
        .map(|p| p.period.clone())
        .unwrap_or_default();
    
    NoveltySummary {
        total_scrobbles,
        total_unique_tracks: unique_tracks.len() as i64,
        total_unique_artists: unique_artists.len() as i64,
        avg_novelty_ratio,
        most_exploratory_period: most_exploratory,
        least_exploratory_period: least_exploratory,
    }
}

fn find_new_artists_discovered(
    scrobbles: &[Scrobble],
    first_artist_occurrence: &HashMap<String, DateTime<Utc>>,
    granularity: Granularity,
) -> Vec<ArtistDiscovery> {
    let mut discoveries: HashMap<String, ArtistDiscovery> = HashMap::new();
    
    for scrobble in scrobbles {
        if let Some(&first_heard) = first_artist_occurrence.get(&scrobble.artist) {
            if first_heard == scrobble.timestamp {
                let period = granularity.format_period(&scrobble.timestamp);
                discoveries.insert(
                    scrobble.artist.clone(),
                    ArtistDiscovery {
                        artist: scrobble.artist.clone(),
                        first_heard,
                        period,
                        total_plays: 0,
                    },
                );
            }
        }
    }
    
    // Count total plays for each discovered artist
    for scrobble in scrobbles {
        if let Some(discovery) = discoveries.get_mut(&scrobble.artist) {
            discovery.total_plays += 1;
        }
    }
    
    let mut result: Vec<_> = discoveries.into_values().collect();
    result.sort_by(|a, b| b.first_heard.cmp(&a.first_heard));
    
    result
}

fn find_top_comfort_tracks(scrobbles: &[Scrobble], limit: usize) -> Vec<ComfortTrack> {
    let mut track_counts: HashMap<(String, String), (i64, DateTime<Utc>)> = HashMap::new();
    
    for scrobble in scrobbles {
        let track_key = (scrobble.artist.clone(), scrobble.track.clone());
        track_counts
            .entry(track_key)
            .and_modify(|(count, first)| {
                *count += 1;
                if scrobble.timestamp < *first {
                    *first = scrobble.timestamp;
                }
            })
            .or_insert((1, scrobble.timestamp));
    }
    
    let mut comfort_tracks: Vec<_> = track_counts
        .into_iter()
        .map(|((artist, track), (count, first_heard))| ComfortTrack {
            artist,
            track,
            play_count: count,
            first_heard,
        })
        .collect();
    
    comfort_tracks.sort_by(|a, b| b.play_count.cmp(&a.play_count));
    comfort_tracks.truncate(limit);
    
    comfort_tracks
}

#[cfg(test)]
mod tests {
    use super::*;
    
    fn test_scrobble(timestamp: &str, artist: &str, track: &str) -> Scrobble {
        Scrobble {
            id: Some(0),
            artist: artist.to_string(),
            album: Some("Test Album".to_string()),
            track: track.to_string(),
            timestamp: timestamp.parse().unwrap(),
            source: "test".to_string(),
            source_id: None,
        }
    }
    
    #[test]
    fn test_first_occurrence_maps() {
        let scrobbles = vec![
            test_scrobble("2024-01-01T10:00:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-01T10:05:00Z", "Artist A", "Track 1"), // Repeat
            test_scrobble("2024-01-01T10:10:00Z", "Artist B", "Track 2"), // New artist & track
        ];
        
        let (first_track, first_artist) = build_first_occurrence_maps(&scrobbles);
        
        assert_eq!(first_track.len(), 2);
        assert_eq!(first_artist.len(), 2);
        
        let track_a1 = ("Artist A".to_string(), "Track 1".to_string());
        assert_eq!(
            first_track.get(&track_a1),
            Some(&"2024-01-01T10:00:00Z".parse().unwrap())
        );
    }
    
    #[test]
    fn test_novelty_point_all_new() {
        let scrobbles = vec![
            test_scrobble("2024-01-01T10:00:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-01T10:05:00Z", "Artist B", "Track 2"),
            test_scrobble("2024-01-01T10:10:00Z", "Artist C", "Track 3"),
        ];
        
        let (first_track, first_artist) = build_first_occurrence_maps(&scrobbles);
        let scrobble_refs: Vec<_> = scrobbles.iter().collect();
        
        let point = compute_novelty_point(
            "2024-01-01".to_string(),
            &scrobble_refs,
            &first_track,
            &first_artist,
        );
        
        assert_eq!(point.total_scrobbles, 3);
        assert_eq!(point.new_tracks, 3);
        assert_eq!(point.repeat_tracks, 0);
        assert_eq!(point.new_artists, 3);
        assert!((point.novelty_ratio - 1.0).abs() < 0.001);
    }
    
    #[test]
    fn test_novelty_point_all_repeats() {
        let scrobbles = vec![
            test_scrobble("2024-01-01T10:00:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-02T10:00:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-03T10:00:00Z", "Artist A", "Track 1"),
        ];
        
        let (first_track, first_artist) = build_first_occurrence_maps(&scrobbles);
        
        // Second period should have 0 new tracks
        let period2_scrobbles: Vec<_> = scrobbles[1..].iter().collect();
        let point = compute_novelty_point(
            "2024-01-02".to_string(),
            &period2_scrobbles,
            &first_track,
            &first_artist,
        );
        
        assert_eq!(point.new_tracks, 0);
        assert!((point.novelty_ratio - 0.0).abs() < 0.001);
    }
    
    #[test]
    fn test_top_comfort_tracks() {
        let scrobbles = vec![
            test_scrobble("2024-01-01T10:00:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-01T10:05:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-01T10:10:00Z", "Artist A", "Track 1"),
            test_scrobble("2024-01-01T10:15:00Z", "Artist B", "Track 2"),
            test_scrobble("2024-01-01T10:20:00Z", "Artist B", "Track 2"),
        ];
        
        let comfort = find_top_comfort_tracks(&scrobbles, 10);
        
        assert_eq!(comfort.len(), 2);
        assert_eq!(comfort[0].artist, "Artist A");
        assert_eq!(comfort[0].track, "Track 1");
        assert_eq!(comfort[0].play_count, 3);
    }
}
